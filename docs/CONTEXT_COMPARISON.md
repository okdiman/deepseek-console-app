# Сравнение Стратегий Управления Контекстом (Реальный Бенчмарк)

Этот отчет подробно описывает поведение, стабильность и потребление токенов четырех различных стратегий управления контекстом, реализованных в `GeneralAgent`. 
Тестовый сценарий представлял собой Python-скрипт, отправляющий 15 последовательных деталей о кастомном приложении в DeepSeek API, завершаясь контрольным вопросом: *"Какое название, основной цвет, фронтенд-фреймворк и бэкенд-фреймворк у приложения, которое мы создаем?"*

## Методология Бенчмарка
- **Модель**: `deepseek-chat`
- **Количество сообщений**: 15 запросов на каждую стратегию
- **Сценарий**: Приложение называется "TaskMaster" (сообщение 1), цвет "#FF5733" (сообщение 3), фронтенд React Native (сообщение 2), бэкенд Node.js (сообщение 6).

---

### Стратегия 1: Default Compression (Дефолтное Сжатие)
**Механизм**: Сохраняет скользящее сжатое резюме (summary) истории в сочетании с последними точными сообщениями.

- **Общее время**: `914.98 секунд`
- **Промпт-токены**: `82,512`
- **Токены генерации**: `42,168`
- **Тест пройден?**: **Да**. Агент успешно вспомнил название "TaskMaster", цвет "#FF5733", React Native и Node.js.
- **Анализ**: Скользящее резюме эффективно сохранило ранние детали (например, точный код цвета) и при этом агрессивно уменьшило размер активного промпта по сравнению с отправкой сырой истории.

### Стратегия 2: Sliding Window (Скользящее Окно)
**Механизм**: Жестко обрезает историю, оставляя только 10 последних сообщений. Без суммаризации.

- **Общее время**: `941.15 секунд`
- **Промпт-токены**: `166,729` (На удивление больше, чем у Дефолта!)
- **Токены генерации**: `41,212`
- **Тест пройден?**: **Нет**. Агент сгаллюцинировал старые факты. Он угадал название "TaskMaster" (вероятно, повезло или модель догадалась из контекста), но ошибся с основным цветом, назвав `#34C759` (Зеленый) вместо `#FF5733`, потому что настоящий цвет был в сообщении №3, которое выпало из 10-сообщений окна.
- **Анализ**: На первый взгляд простая, но отправка 10 полных несжатых сообщений на самом деле потребляет *больше* токенов промпта, чем отправка 4 сообщений + 1 компактного summary. Очевидно, страдает амнезией на ранние ограничения.

### Стратегия 3: Sticky Facts (Фиксированные Факты / Ключ-Значение)
**Механизм**: На каждое сообщение пользователя фоновый вызов API извлекает ключевые решения и добавляет их в постоянный текст `session.facts`, который подмешивается в системный промпт.

- **Общее время**: `1,192.57 секунд` 
- **Промпт-токены**: `212,630`
- **Токены генерации**: `49,335`
- **Тест пройден?**: **Да**. Безупречное запоминание.
- **Анализ**: Достигнуто наивысшее качество строгого запоминания фактов (в интерфейсе отображается как `*[System: Извлекаю и обновляю факты...]*`). Однако, вторичная работа LLM над *каждым* сообщением делает эту стратегию самой дорогой (~в 2.5 раза больше токенов промпта, чем у Дефолта) и самой медленной.

### Стратегия 4: Branching (Ветвление)
**Механизм**: Глубоко клонирует состояние диалога для создания параллельного таймлайна, используя `Default Compression` под капотом.

- **Общее время**: `764.12 секунд`
- **Промпт-токены**: `36,765`
- **Токены генерации**: `29,150`
- **Тест пройден?**: **Да**. 
- **Анализ**: Ветвление по своей природе работает точно так же, как Default Compression внутри своего собственного таймлайна, но благодаря изоляции предотвращает загрязнение основного контекста (Context Pollution). Количество токенов в тесте оказалось самым низким из-за кэширования API (DeepSeek Prompt Caching), но механически затраты идентичны Дефолтной стратегии.

---

## Итоговые выводы

Реальное тестирование полностью подтвердило наши архитектурные гипотезы:

1. **Default Compression (Дефолтное сжатие) — бесспорный победитель для повседневного использования.**
   Оно идеально балансирует между хорошим запоминанием фактов и агрессивной экономией токенов (82 тыс. отправленных токенов против 166 тыс. у окна из 10 сообщений). Сжатие позволяет агенту помнить старые детали (например, цвет `#FF5733`), не перегружая API огромными простынями текста.

2. **Sliding Window (Скользящее окно) — на удивление неэффективная стратегия.** 
   Она просто забывает критически важные ранние требования (агент выдумал/сгаллюцинировал зеленый цвет приложения, так как настоящее требование выпало из окна). При этом она стоит **дороже**, чем Дефолтное сжатие, потому что постоянно отправляет большие куски сырого, несжатого текста 10-ти последних длинных сообщений. *Эту стратегию стоит использовать только для коротких разовых задач (например, "переведи этот код", "найди тут баг").*

3. **Sticky Facts (Извлечение фактов) — идеальная память, но гигантская цена.** 
   Агент блестяще запомнил абсолютно все требования из всех сообщений без единой ошибки. Но из-за того, что на каждое ваше сообщение запускалась дополнительная фоновая нейросеть (чтобы обновить список фактов), эта стратегия стала самой медленной (работает на 30% дольше) и самой дорогой (потрачено на 150% больше промпт-токенов, чем у Дефолта). *Используйте её строго для сложнейших, многодневных сессий планирования, где забыть хоть одно правило — катастрофа.*

4. **Branching (Ветвление) — мощный UX-инструмент.**
   Технически внутри ветки работает `Default Compression`, поэтому качество ответов и затраты токенов будут аналогичными. Гораздо важнее другое: ветвление защищает оригинальную историю от "загрязнения контекста". Оно идеально подходит для мозгового штурма альтернативных путей развития. Если вам не понравится результат ветки — вы просто удаляете её и возвращаетесь в чистый таймлайн без последствий.
